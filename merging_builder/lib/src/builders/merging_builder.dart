import 'dart:async';
import 'package:build/build.dart';
import 'package:exception_templates/exception_templates.dart';
import 'package:glob/glob.dart';
import 'package:path/path.dart' as path show equals;
import 'package:source_gen/source_gen.dart' show LibraryReader;

import '../generators/merging_generator.dart';
import 'formatter.dart';
import 'synthetic_builder.dart';
import 'synthetic_input.dart';

/// Builder that merges its output into one file.
///
/// - Input files must be specified using [Glob] syntax.
///
/// - Requires a generator extending [MergingGenerator].
class MergingBuilder<T, S extends SyntheticInput> extends SyntheticBuilder<S> {
  /// Constructs a [MergingBuilder] object.
  /// * `inputFiles`: Path to the input files relative to the
  /// package root directory. Glob-style syntax is
  /// allowed, defaults to: `'lib/*.dart'`.
  /// * `outputFile`: defaults to: `'lib/merged_output.dart'`.
  /// * `generator`: Must extend `MergingGenerator<T, A>`.
  /// * `header`: `String` that will be inserted at the top of the
  /// generated file below the 'DO NOT EDIT' warning message.
  /// * `footer`: String that will be inserted at the very bottom of the
  /// generated file.
  /// * `formatter`: A function with signature `String Function(String input)`
  /// that is used to format the generated source code.
  /// The default formatter is: `DartFormatter().format`.
  /// Note: The standard Dart formatter will throw an error if the generated
  /// source code contains invalid syntax. To temporarily suppress formatting
  /// use: `(String input) => input`.
  MergingBuilder({
    String inputFiles = 'lib/*.dart',
    this.outputFile = 'lib/merged_output.dart',
    required this.generator,
    String header = '',
    String footer = '',
    this.sortAssets = false,
    Formatter? formatter,
  }) : super(
          inputFiles: inputFiles,
          header: header,
          footer: footer,
          formatter: formatter,
        );

  /// Path to output file relative to the package root directory.
  /// Example: `lib/merged_output.dart`
  final String outputFile;

  /// Class extending [MergingGenerator<T,A>].
  final MergingGenerator<T, dynamic> generator;

  /// Set to true to have assets sorted in reverse topological order of
  /// dependency.
  /// * Defaults to false.
  /// * If a file B includes a file A, then A will be appear
  ///   before B.
  /// * An error is thrown if [sortAssets] is `true` and
  /// a dependency cycle is detected.
  final bool sortAssets;

  @override
  Map<String, List<String>> get buildExtensions => {
        syntheticInput.value: [outputFile]
      };

  /// Writes the merged content to the stand-alone file
  /// specified by [outputFile].
  @override
  FutureOr<void> build(BuildStep buildStep) async {
    // Validate synthetic input/output.
    SyntheticInput.validatePath<S>(inputFiles);
    SyntheticInput.validatePath<S>(outputFile);

    final libraryAssetIds = (sortAssets)
        ? await orderedLibraryAssetIds(buildStep)
        : await this.libraryAssetIds(buildStep);

    // Check if output overwrites input.
    for (final libraryAssetId in libraryAssetIds) {
      if (path.equals(outputFile, libraryAssetId.path)) {
        throw ErrorOf<MergingBuilder>(
            message: 'Output file clashes with input file!',
            expectedState: 'Output files must not overwrite input files. '
                'Check the [MergingBuilder] constructor argument [outputFile].',
            invalidState: 'Output: $outputFile is also an input file.');
      }
    }

    await buildStep.writeAsString(
      AssetId(
        buildStep.inputId.package,
        outputFile,
      ),
      arrangeContent(
        await generator.generateMergedContent(
          _combineStreams(buildStep, libraryAssetIds),
        ),
        generatedBy: 'Generated by ${generator.runtimeType}.',
      ),
    );
  }

  /// Returns a stream of objects of type [T]. Combines the streams
  /// generated by [generator.generateStream]
  /// by iterating over each library file asset.
  Stream<T> _combineStreams(
    BuildStep buildStep,
    Iterable<AssetId> libraryAssetIds,
  ) async* {
    // Accessing libraries.
    for (final libraryAssetId in libraryAssetIds) {
      final library = LibraryReader(
        await buildStep.resolver.libraryFor(libraryAssetId),
      );

      // Calling generator.generateStream. An object of type [T] is
      // emitted for each class defined in library that is annotated with [A].
      log.fine('Running ${generator.runtimeType} on: ${libraryAssetId.path}.');
      final streamOfT = generator.generateStream(library, buildStep);

      // Combining all objects of type [T] into a stream.
      await for (final T t in streamOfT) {
        yield t;
      }
    }
  }
}
